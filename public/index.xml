<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zax&#39; Thoughts</title>
    <link>http://alexanderzafirov.github.io/zafirov.me/</link>
    <description>Recent content on Zax&#39; Thoughts</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 29 Dec 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://alexanderzafirov.github.io/zafirov.me/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A Scala Christmas Tree</title>
      <link>http://alexanderzafirov.github.io/zafirov.me/post/xmastree/</link>
      <pubDate>Thu, 29 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://alexanderzafirov.github.io/zafirov.me/post/xmastree/</guid>
      <description>&lt;p&gt;In the spirit of the Christmas and New Year&amp;rsquo;s festivities, I decided to share with you a short and fun recursive function that can warm your hearts. If not - hopefully it will warm your gray matter a bit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import scala.annotation.tailrec

def xmasTree(height: Int): Unit = {
  @tailrec
  def xmasTree(n: Int, t: Int): Unit = {
    if (n == t) {
      println(&amp;quot; &amp;quot; * (t - n) + &amp;quot;*&amp;quot; * (1 + n * 2))
      println(if (n == 1) &amp;quot; # &amp;quot;
              else if (n == 2) &amp;quot;  #  &amp;quot;
              else List.fill(n / 3)(&amp;quot; &amp;quot; * (n - 1) + &amp;quot;###&amp;quot;).mkString(&amp;quot;\n&amp;quot;)
      )
    } else {
      println(&amp;quot; &amp;quot; * (t - n) + &amp;quot;*&amp;quot; * (1 + n * 2))
      xmasTree(n + 1, t)
    }
  }

  xmasTree(0, height)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Say you run this bad boy like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;xmasTree(12)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the result will be a lovely &amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            *
           ***
          *****
         *******
        *********
       ***********
      *************
     ***************
    *****************
   *******************
  *********************
 ***********************
*************************
           ###
           ###
           ###
           ###
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; Christmas tree :)&lt;/p&gt;

&lt;p&gt;If I were to highlight something about this piece of code, it would be the tail-recursion - which is always awesome to have (and in this case it&amp;rsquo;s verified by the compiler). Then there is the simple math that counts the stars to be printed on the row and amount of spaces to be placed before the stars. Finally we have the trunk implementation which utilizes nested lists - done with &lt;code&gt;List.fill&lt;/code&gt; and (again) simple math to find the proper position of the trunk.&lt;/p&gt;

&lt;p&gt;Happy Holidays!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working with nulls in Spark UDFs</title>
      <link>http://alexanderzafirov.github.io/zafirov.me/post/sparknulls/</link>
      <pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://alexanderzafirov.github.io/zafirov.me/post/sparknulls/</guid>
      <description>&lt;p&gt;Today we are discussing User Defined Functions (UDF) in Spark.&lt;/p&gt;

&lt;p&gt;Sometimes the simplest things are hardest to work out. Let&amp;rsquo;s say I have a &lt;code&gt;DataFrame&lt;/code&gt; created from a parquet file which can have nullable columns that are of a certain type - in this example that is &lt;code&gt;Int&lt;/code&gt;. The reason I chose &lt;code&gt;Int&lt;/code&gt; particularly is that it is &lt;em&gt;not a trivial&lt;/em&gt; case i.e. it doesn&amp;rsquo;t accept &lt;code&gt;null&lt;/code&gt;s as values. The problem that arises is that the &lt;code&gt;DataFrame&lt;/code&gt; can have &lt;code&gt;IntegerType&lt;/code&gt; specified for the schema and still contain &lt;code&gt;null&lt;/code&gt;s. I need to think of something that reflects the fact that I&amp;rsquo;m getting &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; in the same type or else I will get a runtime exception for wrong input type. Tackling this is the goal of this post. On a side note - &lt;code&gt;String&lt;/code&gt; is &lt;em&gt;trivial&lt;/em&gt; since it works with nulls - no need for magic there.&lt;/p&gt;

&lt;p&gt;The first solution to the problem is super ugly. I don&amp;rsquo;t like it but it works. I know that the following could be done with an implicit but I don&amp;rsquo;t like them since they are hard to trace in a bigger code base.&lt;/p&gt;

&lt;p&gt;The first step is to  set the input of the UDF to be &lt;code&gt;Any&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def foo: (Any =&amp;gt; Int) = (a: Any) =&amp;gt; toInt(a) / 100000

val toFoo = udf(foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that the most important thing happens in the &lt;code&gt;toInt&lt;/code&gt; function. Since I have a val of type &lt;code&gt;Any&lt;/code&gt; that may contain a &lt;code&gt;null&lt;/code&gt;, I wrap that in an &lt;code&gt;Option&lt;/code&gt;. After that I proceed to set a default value. Since I&amp;rsquo;m specifying Int and Any as types, the compiler will try and resolve the first common type in the type tree - that is &lt;code&gt;Any&lt;/code&gt; - I need to cast the result to &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def toInt(v: Any): Int = Option(v).getOrElse(0).asInstanceOf[Int]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val outDf = dfParquet
    .withColumn(&amp;quot;foo_column&amp;quot;, toFoo(&#39;a))
    .select(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;foo_column&amp;quot;)
    .show()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Phew! As I said this is not bullet-proof. The reason is that I use &lt;code&gt;Any&lt;/code&gt;, I&amp;rsquo;ve opened the door to all types so if I pass a String, let&amp;rsquo;s say, the &lt;code&gt;asInstanceOf&lt;/code&gt; will fail during execution.&lt;/p&gt;

&lt;p&gt;Luckily the solution is quite simple. Just use Java&amp;rsquo;s &lt;code&gt;Integer&lt;/code&gt; boxed primitive. It is a perfect candidate for the case. This means no conversions from &lt;code&gt;Any&lt;/code&gt;, no opening of Pandora&amp;rsquo;s Any box. If you need to make better sense of the &lt;code&gt;null&lt;/code&gt; value you can leverage on the &lt;code&gt;Option&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;def foo: (Integer =&amp;gt; Option[Integer]) = (i: Integer) =&amp;gt; Option(i).map(_ + 1)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://alexanderzafirov.github.io/zafirov.me/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://alexanderzafirov.github.io/zafirov.me/about/</guid>
      <description>&lt;p&gt;Hello and welcome to my blog. My name is Alex and I am a software engineer. After several years of experience in the IT industry I have already faced some of the main challenges it has to offer. I have been part of big/distributed/multicultural/multilingual teams with skill set that varies from junior to top-notch devs. I would put myself in the middle of that journey, leaning towards the latter part.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m particularly interested in the functional programming paradigm that I try to apply when building software. Scala and the Akka framework capture that concept nicely and give me the freedom to write maintainable, modularized and testable code that is released to production. I like quirky stuff like Bash, vim, Haskell and less quirky stuff like Python.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m also on top of the Data Science hype train since it brings a whole new dimension to the field. I&amp;rsquo;m talking about Spark and a bit of machine learning. And, of course - where would I be if I haven&amp;rsquo;t touched a Docker container (or two), Jenkins, AWS automation scripts for EC2 instance generation, etc.&lt;/p&gt;

&lt;p&gt;While I present you with the tech side of my experience I want to pivot here and say that I also enjoy practising the soft skills and the dynamics that they bring in the data driven environments I like to hang out in. Talking to people from different industries inspires me to learn more about the world we live in and take full advantage of the awesome job I get to practise daily.&lt;/p&gt;

&lt;p&gt;I am not afraid of failure because everything is a learning experience. So as an exercise I decided to start voicing my opinions here in hope that I stand corrected or supported on the solutions to various problems I tackle daily.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>