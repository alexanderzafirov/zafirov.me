---
title: "Core traits of a skilled software engineer"
date: 2020-03-05
description: ""
tags: ["thoughts"]
draft: false
---

Making software in this day and age seems like a trivial task. 
There are cloud providers - Amazon Web Services (AWS), Google Cloud Platform (GCP), Azure - open-source languages, tools and frameworks, 
and many sources like blogs/podcasts/youtube channels where experienced engineers share their success and failure. 
Thus theoretically it should not be hard to learn a tool, write *some code* and solve a problem that exists in the world.

I personally agree and disagree with this statement. 
On one hand I share the view that willingness to learn seems to be the main divider between those who want to craft something 
and those who don't. 
The tools available out there are so stable and mature that they can practically erase the lack of skills on the application developer's side. 
This is also known as _throwing money at the problem_.
On the other hand the countless possibilities to implement an idea lead to an explosion of ways you can mix and match technologies. 
That ability - to distinguish between approaches by choosing based on a comparison between their pros and cons for the given scenario - 
has become a crucial piece in the arsenal of a software engineer.

Hence the name of the game, in my eyes, is developing transferable skills and traits that allow you to drive a product, a team or an organization. 
Subsequently these traits will enable you to make strategic choices about technologies and 
find trade-offs between them such that the software ends up being built is easy to implement and maintain.
This mindset proliferates across the different hats that you as an engineer may be wearing at a given time.
Hiring, establishing engineering and company culture, project selection, process definition, etc. 
These are all things that require educated decisions and dynamic prioritization. 

There is one word that comes to my mind when thinking of the ways to address these requirements - *freedom*. 
In this essay I will walk you through my understanding of the term and how it should be applied to the daily work of a software engineer.
Bear in mind that the traits I will describe are quite interconnected so if you see an overlap or repetition, understand that this is intentional.

## Curiosity

The first manifestation of freedom I will examine is the freedom to be curious. 
I am talking about the pure happiness of making a discovery be that a new framework or plugin that will save you a couple of keystrokes.
The absolute joy of struggling with a problem for a given time and ultimately fulfilling the task or - event better - 
failing miserably and moving on. That is curiosity for me. Some examples include:

- being interested in what the latest and greatest tech with respect to your domain and work is
- willingness to drive the adoption of new technology - this includes overview of cost, technical maintenance and ecosystem around that
- not being satisfied with the status quo and always pushing the evolution of the practises adopted in the organization whenever they can be improved
- willingness to contribute time for the betterment of everyday tasks for all colleagues - technical and non-technical alike

It is very important that people who want to build software have a strong internal drive and find challenges interesting, and not off-putting. 
That will surely keep an engineer going after long hours of work, frustration or failure. 
That inner passion to deliver a functioning piece of software - it takes time and dedication but most importantly being curious of seeing how the whole thing plays out.
Does the software handle the load for a prolonged period of time? Does the algorithm bring better performance? Is the designed architecture scalable?
Answers to questions like these are found only by the persistent and the curious.

## Ownership

The next incarnation of freedom is ownership. There's a certain duality when it comes to owning something fully.
When I was coming in the software industry I had the impression that ownership is about who gets to say that they finished a given task - 
who gets the glory! 
Eventually I learned that there is also maintenance - the not so exciting repetitive work - and the scary production downtimes or process failures.
This is what making something truly yours means - caring for it, thinking of it without needing a nudge from colleagues, managers and - in the worst case - customers.

In my mind ownership of a problem and the proposed solution translates to things like:
- involvement - expressing interest throughout the whole lifecycle of a task - through conception, implementation and maintenance
- transparency - documentation, setup of monitoring and alerting, technical sparing with teammates
- proactive maintenance - keeping the project's tech stack and practises up-to-date
- challenging stakeholders - when working within a given domain, the engineer develops not only technical but also domain expertise. 
It is very much encouraged for engineers to protect the product by educating business people on what is actually possible.
Otherwise "visionaries" may push the project to an inconsistent and unmaintainable state from a technology perspective.
- commitment - deadlines should be set with both engineers and stakeholders signing off on them. 
Being able to communicate obstacles and challenges as well as working hard towards a deliverable is what I expect of every person that gives their word.

## Inclusion

Even though I have mentioned many things so far that may seem daunting for a single person we are lucky because software is not built in isolation. 
Hence the next way to look at freedom is through the lens of being free to learn about any problem, product or be part of any discussion that relates to your daily activities.
No tasks come from the consciousness in the sky. There are no superheroes that decide how the world runs and fix everything at their will. 

One way to achieve this is by creating a forum where engineers across teams can discuss freely amongst each other topics that include tools and processes.
Everything can be challenged and is up for debate as long as the conversation is constructive and there is a tangible outcome.
It is an event that takes place once a week where all the engineers sit down and discuss topics that were brought up by themselves during the past working week. 
After a round table discussion, a task is assigned and a document describing briefly what was said is uploaded online for everyone interested to see. 
The way curiosity plays a part in this practise is the openness with which discussions are held, the ability for everyone to challenge the status quo and the fair treatment that every problem gets during the meeting. 

Another common practise that displays inclusion is *Post-mortem*. 
We all make mistakes and are will continue making them. 
Our goal is to internalize the lessons we get from them, leave egos aside and focus on the team's success. 
Thus whenever a problem is discovered in the system, the focus falls on bringing that back to a safe state - by doing a rollback or a hotfix. 
Once that is done, a short description the problem that caused disturbance follows. 
It contains the root cause, the short term and long term solutions. 
That brings transparency, clarity and peace of mind around the organization as it is visible that the team has prioritized their tasks accordingly - 
allowing customers and colleagues alike to work undisturbed.

## Be a generalist

Engineers with different backgrounds and that to be a great asset to us. A things that we value in the engineers here is that they can have their go-to technology - be that Scala, Kafka, DynamoDB, etc. - but they can still reason on basic principles. That way we can address something that I discussed in the beginning - the ability to choose one technology over next. This is crucial because:

- it allows us to feel happy when working with something new
- it makes us be relaxed that it will not break in the middle of the night
- it makes us feel confident that we can find help when necessary in forums/Gitter/stackoverflow
- it ensures that we can pass the knowledge to a colleague that can adopt the project and continue expanding it

All these perks will not be possible if people are narrow minded and have their very special preference towards one single technology that their are masters of yet fail to grasp the greater concepts. Thus the most important thing is realizing that it is the difference between technologies that matters and the way they relate to one another.

## Conclusions

Building software is a cognitively and physically daunting task. 
Having to keep a great deal of context in mind, be positive, be communicative and transparent, 
all the while finding time to fix problems that effect other engineers. This seems to be taken for granted in companies today.
To enable that to happen without having people burning out is a task of organizations and more specifically the culture that they foster. 

